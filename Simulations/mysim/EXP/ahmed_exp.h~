#ifndef _AHMED_EXPERIMENT_
#define _AHMED_EXPERIMENT_

#include "experiment.h"
#include <tuple>
#include <bits/stdc++.h>

//#define WITH_COLLISION_CHECK
//#define SIMPLE_CAMERA
#define FLOOR_SENSORS


class Ahmed_experiment : public Experiment {
private:
    vector<vector<double> > inputs;      // all sensory inputs
    vector<vector<double> > outputs;     // outputs generated by the controller, used to move robots
    vector<vector<double> > ir_ray_length; // length of ir ray after tracying
    vector<vector<double> > floor_sensor_readings; //Readings of the floor sensors
    vector<int> idActiveAgents;
    vector<double> m_local_fitness;
    vector<vector<double> > m_robot_robot_distance;
    int m_num_neighbours;
    vector<vector<double> > ctrnn_input;
    vector<vector<double> > ctrnn_output;
    vector<double> desired_output;


    std::vector<Controller *> m_pfsm;

public:
    Ahmed_experiment(Parameters *params);

    virtual ~Ahmed_experiment();

    void evaluate_solutions(void);

    void init_evaluations_loop(void);

    void init_single_evaluation(void);

    void adv(void);

    bool stop_iterations_loop(void);

    bool stop_evaluations_loop(void);

    void finalise_single_evaluation(void);

    void finalise_evaluation_loop(void);

    void set_agents_position(int);

    void update_sensors(void);

    void update_controllers(void);

    void update_actuators(void);

    void update_world(void);

    void update_optic_flow_sensors(void);

    void manage_collisions_without_repositioning(void);

    void manage_collisions_with_repositioning(void);

    void compute_fitness(void);

    void save_sound_tracks(void);

    inline vector<double> get_ir_ray_length(int r) { return ir_ray_length[r]; }
};

#endif
